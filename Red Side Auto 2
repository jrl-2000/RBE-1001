#include "vex.h"
using namespace vex;

vex::brain      Brain;
vex::motor      LeftMotor(vex::PORT1, vex::gearSetting::ratio18_1, false);
vex::motor      RightMotor(vex::PORT2, vex::gearSetting::ratio18_1, true);
vex::motor      motor_3(vex::PORT3, vex::gearSetting::ratio18_1, false);
vex::motor      motor_5(vex::PORT5, vex::gearSetting::ratio18_1, false);
vex::motor      motor_8(vex::PORT8, vex::gearSetting::ratio18_1, false);
vex::line       line_left(Brain.ThreeWirePort.A);
vex::line       line_right(Brain.ThreeWirePort.B);
vex::controller con(vex::controllerType::primary);


vex::competition Competition;

void pre_auton() {


}

void autonomous() {
enum state {driving, turning, movearmlevelup, movingtodorm, deliverpizza, linefollowback, turntopizzeria, 
raisearm, drivetopizzeria, intake, drivebackwards, turn, movetodorm, deliversecondpizza, backup, done};
    
    state cstate = driving;
    
    while (cstate != done){
    
    switch (cstate) {
        case driving:
            LeftMotor.startRotateFor(18, rotationUnits::rev, 100, velocityUnits::pct);
            RightMotor.rotateFor(18, rotationUnits::rev, 100, velocityUnits::pct);
            cstate=turning;
            break;
        case turning:
            RightMotor.startRotateFor(-5*0.72, rotationUnits::rev, 60, velocityUnits::pct);  //turn right, not left 
            LeftMotor.rotateFor(5*0.72, rotationUnits::rev, 60, velocityUnits::pct);
            cstate=movearmlevelup;
        case movearmlevelup:
            motor_8.startRotateFor(0.490, rotationUnits::rev, 50, velocityUnits::rpm);
            cstate=movingtodorm;
            break;
        case movingtodorm:
            LeftMotor.startRotateFor(5*10.5/(4*3.14159), rotationUnits::rev, 100, velocityUnits::pct);  //moves 32 inches forward
            RightMotor.rotateFor(5*10.5/(4*3.14159), rotationUnits::rev, 100, velocityUnits::pct);
            cstate=deliverpizza;
            break;
        case deliverpizza:
            motor_5.rotateFor(3, rotationUnits::rev, 100, velocityUnits::rpm);
            Brain.Screen.print("PIZZA DELIVERY");
            cstate=linefollowback;
            break;
        case linefollowback:
            while (cstate == linefollowback) {
            if (line_left.value(vex::analogUnits::range12bit)>1000 || line_right.value(vex::analogUnits::range12bit)>1000){
                float KP = 2;
                float sensorleft = line_left.value(vex::percentUnits::pct);
                float sensorright = line_right.value(vex::percentUnits::pct);
                float errorright = sensorleft-sensorright;
                float errorleft = sensorright-sensorleft;
                RightMotor.spin(directionType::rev, 70- KP*errorright, velocityUnits::rpm);       
                LeftMotor.spin(directionType::rev, 70- KP*errorleft, velocityUnits::rpm);
                }
            else{LeftMotor.stop(); RightMotor.stop(); cstate=turntopizzeria;} 
        }
            cstate=turntopizzeria;
            break;
        case turntopizzeria:
            RightMotor.startRotateFor(-5*0.72, rotationUnits::rev, 60, velocityUnits::pct);     //turn right, not left
            LeftMotor.rotateFor(5*0.72, rotationUnits::rev, 60, velocityUnits::pct);
            cstate=raisearm;
            break;
        case raisearm:
            motor_8.startRotateFor(0.490, rotationUnits::rev, 50, velocityUnits::rpm);
            cstate=drivetopizzeria;
            break;
        case drivetopizzeria:
            LeftMotor.startRotateFor(17.5, rotationUnits::rev, 100, velocityUnits::pct);
            RightMotor.rotateFor(17.5, rotationUnits::rev, 100, velocityUnits::pct);
            cstate=intake;
            break;
        case intake:
            motor_5.rotateFor(-4, rotationUnits::rev, 100, velocityUnits::rpm);
            cstate=drivebackwards;
            break;
        case drivebackwards:
            LeftMotor.startRotateFor(-16.5, rotationUnits::rev, 100, velocityUnits::pct);
            RightMotor.rotateFor(-16.5, rotationUnits::rev, 100, velocityUnits::pct);
            cstate=turn;
            break;
        case turn:
            RightMotor.startRotateFor(5*0.72, rotationUnits::rev, 60, velocityUnits::pct);     //turn left, not right
            LeftMotor.rotateFor(-5*0.72, rotationUnits::rev, 60, velocityUnits::pct);
            cstate=movetodorm;
            break;
        case movetodorm:
            LeftMotor.startRotateFor(5*16/(4*3.14159), rotationUnits::rev, 100, velocityUnits::pct);  //moves 32 inches forward
            RightMotor.rotateFor(5*16/(4*3.14159), rotationUnits::rev, 100, velocityUnits::pct);
            cstate=deliversecondpizza;
            break;
        case deliversecondpizza:
            motor_5.rotateFor(3, rotationUnits::rev, 100, velocityUnits::rpm);
            Brain.Screen.print("PIZZA DELIVERY");
            cstate= backup;
            break;
        case backup:
            LeftMotor.startRotateFor(-5*6/(4*3.14159), rotationUnits::rev, 100, velocityUnits::pct);  //moves 32 inches forward
            RightMotor.rotateFor(-5*6/(4*3.14159), rotationUnits::rev, 100, velocityUnits::pct);
            cstate=done;
            break;
        case done:
            break;
        default:
           Brain.Screen.print("well that didn't work");
           break;
    }
    
    }

}

void drivercontrol() {
    while (true) {
 if (con.ButtonL1.pressing()==1) {
    motor_8.startRotateFor(0.480, rotationUnits::rev, 40, velocityUnits::rpm);
}
if (con.ButtonL2.pressing()==1) {
    motor_8.startRotateFor(-0.38, rotationUnits::rev, 40, velocityUnits::rpm);
}

if (con.ButtonUp.pressing()==1) {
    motor_5.startRotateFor(2, rotationUnits::rev, 100, velocityUnits::rpm);
}
if (con.ButtonDown.pressing()==1) {
    motor_5.startRotateFor(-2, rotationUnits::rev, 100, velocityUnits::rpm);
}
while (con.ButtonR2.pressing()==1) {
    motor_3.spin(directionType::fwd, 50, velocityUnits::pct);
    }
if (con.ButtonR2.pressing()==0) {
    motor_3.stop(brakeType::hold);
    }
while (con.ButtonR1.pressing()==1) {
    motor_3.spin(directionType::rev, 50, velocityUnits::pct);
    }
if (con.ButtonR1.pressing()==0) {
    motor_3.stop(brakeType::hold);
    
}


LeftMotor.spin(directionType::fwd, 5*(con.Axis3.value() + con.Axis1.value())/2, velocityUnits::pct); //(Axis2+Axis1)/2;
RightMotor.spin(directionType::fwd, 5*(con.Axis3.value() - con.Axis1.value())/2, velocityUnits::pct);//(Axis2-Axis1)/2;


    }
}

int main() {
    Competition.autonomous(autonomous);
    Competition.drivercontrol(drivercontrol);
    pre_auton();
}
