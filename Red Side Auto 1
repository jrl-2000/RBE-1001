#include "vex.h"
using namespace vex;

vex::brain      Brain;
vex::motor      LeftMotor(vex::PORT1, vex::gearSetting::ratio18_1, false);
vex::motor      RightMotor(vex::PORT2, vex::gearSetting::ratio18_1, true);
vex::motor      motor_3(vex::PORT3, vex::gearSetting::ratio18_1, false);
vex::motor      motor_5(vex::PORT5, vex::gearSetting::ratio18_1, false);
vex::motor      motor_8(vex::PORT8, vex::gearSetting::ratio18_1, false);
vex::line       line_left(Brain.ThreeWirePort.A);
vex::line       line_right(Brain.ThreeWirePort.B);
vex::controller con(vex::controllerType::primary);


vex::competition Competition;

void pre_auton() {

}

void autonomous() {
    
    enum state {armupfloor, drivingforwardtobump, raisingback, drivingforwardonbump, raisingrack, drivingoffbump, drivingintoconstruction, 
    backingup, loweringarm, turningtodorm, drivingtodorm, deliveringpizza, movingback, turningfortele, done};
    
    state cstate = armupfloor;
    
    while (cstate != done){
    
    switch(cstate){
        case armupfloor:
            motor_8.startRotateFor(0.490, rotationUnits::rev, 50, velocityUnits::rpm);
            cstate=drivingforwardtobump;
            break;
        case drivingforwardtobump:
            LeftMotor.startRotateTo(5*30/(4*3.14159), rotationUnits::rev, 70, velocityUnits::pct);
            RightMotor.rotateTo(5*30/(4*3.14159), rotationUnits::rev, 70, velocityUnits::pct);
            cstate=raisingback;
            break;
        case raisingback:
            motor_3.rotateFor(2, rotationUnits::rev, 50, velocityUnits::pct);
            cstate=drivingforwardonbump;
            break;
        case drivingforwardonbump:
            LeftMotor.startRotateFor(5*6/(4*3.14159), rotationUnits::rev, 70, velocityUnits::pct);
            RightMotor.rotateFor(5*6/(4*3.14159), rotationUnits::rev, 70, velocityUnits::pct);
            cstate=raisingrack;
            break;
        case raisingrack:
            motor_3.rotateFor(-2, rotationUnits::rev, 50, velocityUnits::pct);
            cstate=drivingoffbump;
            break;
        case drivingoffbump:
            LeftMotor.startRotateFor(5*10/(4*3.14159), rotationUnits::rev, 30, velocityUnits::pct);
            RightMotor.rotateFor(5*10/(4*3.14159), rotationUnits::rev, 30, velocityUnits::pct);
            cstate=drivingintoconstruction;
            break;
        case drivingintoconstruction: 
             while(cstate==drivingintoconstruction){
                 if(line_left.value(vex::analogUnits::range12bit)>850 || line_right.value(vex::analogUnits::range12bit)>850){
                    LeftMotor.spin(directionType::fwd, 30, velocityUnits::pct);
                    RightMotor.spin(directionType::fwd, 30, velocityUnits::pct); 
                 }
                else{LeftMotor.stop(); RightMotor.stop(); cstate=backingup;} 
            }
            break;
        case backingup:
            RightMotor.startRotateFor(-5*6/(4*3.14159), rotationUnits::rev, 50, velocityUnits::pct);
            LeftMotor.rotateFor(-5*6/(4*3.14159), rotationUnits::rev, 50, velocityUnits::pct);
            cstate= loweringarm;
        case loweringarm:
            motor_8.startRotateFor(-0.025, rotationUnits::rev, 50, velocityUnits::rpm);
            cstate=turningtodorm;
        case turningtodorm:
            RightMotor.startRotateFor(5*0.72, rotationUnits::rev, 60, velocityUnits::pct);       //turns left, not right
            LeftMotor.rotateFor(-5*0.72, rotationUnits::rev, 60, velocityUnits::pct);
            cstate=drivingtodorm;
            break;
        case drivingtodorm:
            RightMotor.startRotateFor(5*5/(4*3.14159), rotationUnits::rev, 100, velocityUnits::pct);      
            LeftMotor.rotateFor(5*5/(4*3.14159), rotationUnits::rev, 100, velocityUnits::pct);
            cstate=deliveringpizza;
            break;
        case deliveringpizza:
            motor_5.rotateFor(3, rotationUnits::rev, 100, velocityUnits::rpm);
            Brain.Screen.print("PIZZA DELIVERY");
            cstate=movingback;
            break; 
        case movingback:
            while (cstate == movingback) {
            if (line_left.value(vex::analogUnits::range12bit)>1000 || line_right.value(vex::analogUnits::range12bit)>1000){
                float KP = 1;
                float sensorleft = line_left.value(vex::percentUnits::pct);
                float sensorright = line_right.value(vex::percentUnits::pct);
                float errorright = sensorleft-sensorright;
                float errorleft = sensorright-sensorleft;
                RightMotor.spin(directionType::rev, 50- KP*errorright, velocityUnits::rpm);       
                LeftMotor.spin(directionType::rev, 50- KP*errorleft, velocityUnits::rpm);
                }
            else{LeftMotor.stop(); RightMotor.stop(); cstate=turningfortele;} 
        }
            break;
        case turningfortele:
            RightMotor.startRotateFor(5*0.72, rotationUnits::rev, 60, velocityUnits::pct);    //turn left, not right  
            LeftMotor.rotateFor(-5*0.72, rotationUnits::rev, 60, velocityUnits::pct);
            cstate=done;
        case done:
            break;
        default:
           Brain.Screen.print("well that didn't work");
           break;
        
    }
    }
    
}

void drivercontrol() {
    while (true) {
        if (con.ButtonL1.pressing()==1) {
    motor_8.startRotateFor(0.480, rotationUnits::rev, 40, velocityUnits::rpm);
}
if (con.ButtonL2.pressing()==1) {
    motor_8.startRotateFor(-0.38, rotationUnits::rev, 40, velocityUnits::rpm);
}

if (con.ButtonUp.pressing()==1) {
    motor_5.startRotateFor(2, rotationUnits::rev, 100, velocityUnits::rpm);
}
if (con.ButtonDown.pressing()==1) {
    motor_5.startRotateFor(-2, rotationUnits::rev, 100, velocityUnits::rpm);
}
while (con.ButtonR2.pressing()==1) {
    motor_3.spin(directionType::fwd, 50, velocityUnits::pct);
    }
if (con.ButtonR2.pressing()==0) {
    motor_3.stop(brakeType::hold);
    }
while (con.ButtonR1.pressing()==1) {
    motor_3.spin(directionType::rev, 50, velocityUnits::pct);
    }
if (con.ButtonR1.pressing()==0) {
    motor_3.stop(brakeType::hold);
    
}


LeftMotor.spin(directionType::fwd, 5*(con.Axis3.value() + con.Axis1.value())/2, velocityUnits::pct); 
RightMotor.spin(directionType::fwd, 5*(con.Axis3.value() - con.Axis1.value())/2, velocityUnits::pct);



}
}

int main() {
    Competition.autonomous(autonomous);
    Competition.drivercontrol(drivercontrol);
    pre_auton();
}
